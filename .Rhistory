gnb_check_input <- function(X,y){
# Guard statements, ensures input data validity.
if(!is.data.frame(X)) {
stop("Parameter X must be a data frame, please provide the data frame whose columns are numeric variables and rows are observations")
}
# Check if length of vector y matches number of rows in matrix X
if(!(nrow(X)==length(y))) stop("Length of response vector y must be equal to number of rows in X")
# Helper function to verify input.
binary_vector_check <- function(input_vector){
if(!is.integer(input_vector)) stop("Please provide an integer vector")
is_binary <- all(input_vector <= 1) && all(input_vector >= 0)
if(!is_binary) stop("Please provide an integer vector of 1's and 0's")
return(TRUE)
}
# Check if y is made of 1's and 0's, where 1 = increase in price since yesterday, 0 = decrease or no increase
binary_vector_check(y)
}
bayesian_estimate <- function(sigma,means,n) {
out <- ((sigma^2)/(sigma^2 + n))*((n/sigma^2)*means)
return(out)
}
gaussian_nb <- function(X,y,bayes_estimator=FALSE){
gnb_check_input(X,y)
# First make empirical estimates of prior probability P(Y) and P(X|Y)
# P(Y) is easy to calculate, just find the proportion of labels, in this case
# occurence of label=1 over total observation n
# sum(y) gives total days which we observe increase in S&P500
# length(y) gives total observations (i.e. days)
prior_Y_one <- sum(y) / length(y)
prior_Y_zero <- 1 - prior_Y_one
# For empirical P(X|Y), if X was discrete we we do a similar proportion calculation as above
# Since our X's are stock related metrics, we will assume P(X|Y) follows some distribution, e.g. gaussian
# First we need to find mean and sd for rows where Y = 0,1 in order to calculate gaussian pdf
# we need the mean and sd for Y = 1 and Y = 0, for each column j = 1,..,p
# Therefore we will have p x k number of different mew and sigma in total
X_given_one_subset <- X[as.logical(y),] # subset only rows where Y = 1
X_given_zero_subset <- X[as.logical(1-y),] # subset only rows where Y = 0
mew_one = 0 # initialize mew
sigma_one = 1 # initialize sigma
mew_zero = 0 # initialize mew
sigma_zero = 1 # initialize sigma
if (bayes_estimator == FALSE){
mew_one = sapply(X_given_one_subset,mean)
sigma_one = sapply(X_given_one_subset,sd)
mew_zero = sapply(X_given_zero_subset,mean)
sigma_zero = sapply(X_given_zero_subset,sd)
} else {
# Some bayes estimator function output:
n <- nrow(X)
mew_one <- sapply(X_given_one_subset,mean) # replace mean function with something else!
sigma_one <- sapply(X_given_one_subset,sd) # replace sd function with something else!
mew_one <- bayesian_estimate(sigma_one,mew_one,n)
mew_zero <- sapply(X_given_zero_subset,mean) # replace mean function with something else!
sigma_zero <- sapply(X_given_zero_subset,sd) # replace sd function with something else!
mew_zero <- bayesian_estimate(sigma_zero,mew_zero,n)
}
# Initialize a data frame of size n x p to hold P(Xij|Y=k) for each entry Xij of data matrix X
X_given_Y_one <- data.frame(matrix(nrow = nrow(X),ncol = ncol(X))) # Y = 1
X_given_Y_zero <- data.frame(matrix(nrow = nrow(X),ncol = ncol(X))) # Y = 0
# For every individual row, calculate the prob(Xij|Y = 1), recall that we are fitting a gaussian distribution for this
# The notation prob(Xij|Y = 1) is mathematically inaccurate, this would be a probability density not a probability!
# This still works as an application of bayes rule but will be explained below.
# Use appropriate mew & sigma corresponding to column p and class Y = k
for (i in 1:nrow(X)){
row_data = X[i,]
for (p in 1:ncol(X)){
prob_XY <- dnorm(row_data[[p]],mew_one[p],sigma_one[p])
X_given_Y_one[i,p] <- prob_XY
}
}
# For every individual row, calculate the prob(Xij|Y = 0)
for (i in 1:nrow(X)){
row_data <- X[i,]
for (p in 1:ncol(X)){
prob_XY <- dnorm(row_data[[p]],mew_zero[p],sigma_zero[p])
X_given_Y_zero[i,p] <- prob_XY
}
}
# Recall P(Y=1|Xij) = P(Xi1|Y=1)...P(Xip|Y=1)P(Y=1) / P(Y=1|Xij) = P(Xi1|Y=1)...P(Xip|Y=1)P(Y=1) + P(Xi1|Y=0)...P(Xip|Y=1)P(Y=0)
# Numerator = P(Xi1|Y=1)...P(Xip|Y=1)P(Y=1)
row_product_ones <- apply(X_given_Y_one,1,prod) # take product of entire row from rows 1...n
numerator_ones <- row_product_ones*prior_Y_one
# Denominator = P(Xi1|Y=1)...P(Xip|Y=1)P(Y=1) + P(Xi1|Y=0)...P(Xip|Y=1)P(Y=0)
row_product_zeros <- apply(X_given_Y_zero,1,prod)
numerator_zeros <- row_product_zeros*prior_Y_zero
# Even though P(Xij|Y=k) is a density not a probability, but because the numerator is a component of the denominator,
# P(Y=1|Xij) will at most be equal to one, this normalizes the entire equation and therefore its value is between 0 to 1
posteriors_ones <- numerator_ones / (numerator_ones + numerator_zeros)
posteriors_zeros <- numerator_zeros / (numerator_ones + numerator_zeros)
# Predictions
# If P(Y=1|Xij) > P(Y=0|Xij), i.e. likelihood of class 1 is greater,
# we will label the observation row i as class Y = 1
predictions <- ifelse(posteriors_ones>posteriors_zeros,1,0)
# Generate list of outputs: (1) Prior Probabilities of Y, (2) Class conditional probabilities P(Xij|Y=k),
# (3) Posterior probabilities, (4) Predicted Labels for each data row, (5) accuracy
output_priors <- c(prior_Y_zero,prior_Y_one)
class_conditional_DF_list <- list(X_given_Y_zero,X_given_Y_one)
posteriors_DF <- data.frame(posteriors_zeros,posteriors_ones)
accuracy <- sum(ifelse(predictions==y,1,0))/nrow(X)
# Generate a named list for easy access to elements.
# E.g. output_list$priors will access first element etc
output_list <- list(priors = output_priors, class_conditional_DF_list = class_conditional_DF_list,
posteriors_DF = posteriors_DF, predictions = predictions, means_zero = mew_zero, means_one = mew_one,
accuracy = accuracy,sigma_one = sigma_one,sigma_zero = sigma_zero)
return(output_list)
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
stock_data_raw <- read.table("test_stock_data.txt")
X_stocks <- stock_data_raw[,1:ncol(stock_data_raw)-1]
y_stocks <- stock_data_raw[,ncol(stock_data_raw)]
y_stocks <- as.integer(y_stocks)
print("MLE")
nb_output <- gaussian_nb(X_stocks,y_stocks,FALSE)
print("means for class 0")
print(nb_output$means_zero)
nb_output_MLE <- gaussian_nb(X_stocks,y_stocks,FALSE)
nb_output_Bayes <- gaussian_nb(X_stocks,y_stocks,TRUE)
print(nb_output_MLE$accuracy)
print(nb_output_Bayes$accuracy)
